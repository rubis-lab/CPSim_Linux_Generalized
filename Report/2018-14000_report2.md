# Case1

In case 1, we had to write a task_read_write_logger. First I thought that declaring a new struct type that can pass the logging information to the logger would be a solution. However, since the specifications recommended that we take the task_name as the input parameter string, I formatted the log string in Job.cpp and passed the formatted string to the logger. 
The run_function() in Job.cpp was where I called the logging function. The run_function splits up into three cases, depending on whether the job reads and writes, or if it reads only or writes only. In all cases, the problem was to get the data size, because that is not specified in the code. Thus, I added up sizeof(int) when the data_read# of data_write# value was not set to 0. This is because in EthernetClient.cpp, I realized that data is set to 0 when nothing is written or read. After adding up the data size in a variable called total_size, I could format the logging string. The task name was obvious because that was declared in utils::log_task.c_str(). The current time was also obvious - it was in utils::current_time. However one thing to be careful about was the fact that the current_time was stored in milliseconds, so I decided the value by 1000 to get the correct timing value in seconds. 
In the logger, I opened up a file, checked if it was empty (if it is newly opened), and if so, I wrote a header to the file. In cases where the open file its not empty (I opened files with the appending option, so that the previously logged strings will not be overwritten), I just put the task_name (the formatted logging string) to the file. 


# Case2
In case 2, we had to write a real_cyber_event_logger. This was much more difficult than case 1 for the two main reasons.  
  
1)I was not sure where to call the logging function in Executor.cpp. However, after careful examination of Executor.cpp, I realized that there are lines where they set the job’s start time or release time, or lines where they check if the job is finished or not. In large, I called to logging function 6 times in Executor.cpp. The first one is when there is a deadline miss, the second and third calls were to log the release time, by giving the time parameter as get_simulated_release_time. The fourth call was to log the start time by giving the time parameter as get_simulated_start_time. The fifth and sixth calls were to log the finish time.  
  
2)I could not log the logging string right away when the logger was called. Unlike case1, where each read and write were performed in time sequence, the time scheduled for the jobs in in this case was not time-sequential. Thus, writing the in the logger every time the logger is called would mess up the time index in the log. Thus, to solve this problem, I declared a log vector to store the log information (time, job_id, jobnum, and event_type). The time, job_id and event types are all passed as a parameter to the logger. Thus, I needed a way to keep track of the job number (i.e. what is this job’s order among the same event type tasks?). Thus, I declared three arrays in utils.h, which are initialized to 0. For each array, index at ‘job_id’ will hold the job order for the new job. Getting the jobnum, I used a struct type (LogInfo) and pushed the struct to the log vector. When the run_simulation function reaches its end, I called write_to_event_log function declared also in Logger.cpp. In this function, I took the log vector, and sorted it with regard to time, formatted the log string, and wrote the string onto the file.

